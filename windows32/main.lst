Microsoft (R) Macro Assembler Version 11.00.50727.1	    10/13/16 20:31:14
main.asm						     Page 1 - 1


				.586
				.MODEL FLAT	; only 32 bit addresses, no segment:offset

				INCLUDE io.h   ; header file for input/output
			      C ; IO.H -- header file for I/O macros (listing suppressed)
			      C .NOLIST      ; turn off listing
			      C .LIST        ; begin listing
			      C 

				.STACK 4096	   ; allocate 4096 bytes for the stack

 00000000			.DATA
					; This is an unsigned problem. There are no negative numbers in this code.
					; The array elements will be bytes, because they will be ASCII coded strings.

						; This string will be used with the input macro to get a string from the user.
						; We will make it 40 characters long, because that seems reasonable.
						; We will actually need it to be 41 characters long, because the input macro will add a null terminator.
 00000000  00000029 [			inputStr BYTE 41 DUP ("x")
	    78
	   ]

						; This string will serve as a prompt for getting input from the user.
						; It must be null-terminated because that is what the input macro expects.
 00000029 50 6C 65 61 73		inputPrompt BYTE "Please enter a string. (Max 40 characters)", 0
	   65 20 65 6E 74
	   65 72 20 61 20
	   73 74 72 69 6E
	   67 2E 20 28 4D
	   61 78 20 34 30
	   20 63 68 61 72
	   61 63 74 65 72
	   73 29 00

						; This string will be used to output the count values
						; Each variable needs 11 characters because that's what dtoa gives
 00000054 54 68 65 20			outputStr		BYTE "The "
 00000058  0000000B [			charCountText	BYTE 11 DUP ("X")
	    58
	   ]
 00000063  20 63 68 61 72						BYTE " characters in the string represent"
	   61 63 74 65 72
	   73 20 69 6E 20
	   74 68 65 20 73
	   74 72 69 6E 67
	   20 72 65 70 72
	   65 73 65 6E 74
 00000086  0D 0A							BYTE 13, 10 ; CRLF
 00000088  0D 0A							BYTE 13, 10 ; CRLF
 0000008A  0000000B [			upperCountText	BYTE 11 DUP ("X")
	    58
	   ]
 00000095  20 75 70 70 65						BYTE " uppercase letters"
	   72 63 61 73 65
	   20 6C 65 74 74
	   65 72 73
 000000A7  0D 0A							BYTE 13, 10 ; CRLF
 000000A9  0000000B [			lowerCountText	BYTE 11 DUP ("X")
	    58
	   ]
 000000B4  20 6C 6F 77 65						BYTE " lowercase letters"
	   72 63 61 73 65
	   20 6C 65 74 74
	   65 72 73
 000000C6  0D 0A							BYTE 13, 10 ; CRLF
 000000C8  0000000B [			digitCountText	BYTE 11 DUP ("X")
	    58
	   ]
 000000D3  20 64 69 67 69						BYTE " digits"
	   74 73
 000000DA  0D 0A							BYTE 13, 10 ; CRLF
 000000DC  0000000B [			spaceCountText	BYTE 11 DUP ("X")
	    58
	   ]
 000000E7  20 73 70 61 63						BYTE " spaces"
	   65 73
 000000EE  0D 0A							BYTE 13, 10 ; CRLF
 000000F0  0000000B [			otherCountText	BYTE 11 DUP ("X")
	    58
	   ]
 000000FB  20 6F 74 68 65						BYTE " other"
	   72
 00000101  00								BYTE 0						; null terminator


						; These numbers will track the numbers of different types of characters in inputStr
						; We're using bytes because the length of inputStr will not exceed 40 characters.
 00000102 00				lowerCaseCount BYTE 0
 00000103 00				upperCaseCount BYTE 0
 00000104 00				digitCount BYTE 0
 00000105 00				spaceCount BYTE 0
 00000106 00				otherCount BYTE 0

 00000000			.CODE
 00000000			_MainProc PROC
					

					; start at first character in inputStr
					; while (not past end of inputStr) {
					;     if (current character is between "a" and "z" inclusive) {
					;	      count it as lowercase
					;     } else
					;     if (current character is between "A" and "Z" inclusive) {
					;	      count it as uppercase
					;     } else
					;     if (current character is between "0" and "9" inclusive) {
					;	      count it as a digit
					;     } else
					;     if (current character is a space) {
					;         count it as a space
					;     } else {
					;         count it as other
					;     }
					;     go to next character
					; }

					input inputPrompt, inputStr, 40	; read input from user into inputStr (max 40 characters)

 0000001E  8D 1D 00000000 R		lea ebx, inputStr				; address of first byte of inputStr into ebx.
													; char := first character of inputStr
 00000024  BF 00000000			mov edi, 0						; index := 0
 00000029			countLoop:
 00000029  80 3C 3B 00			cmp BYTE PTR [ebx + 1*edi], 0	; char == 0?
 0000002D  74 5A			jz exitCountLoop				; quit upon reaching 0
					
 0000002F  80 3C 3B 61			cmp BYTE PTR [ebx + 1*edi], "a"
 00000033  72 0F			jb notLowerCase					; when char < "a", not lower case
 00000035  80 3C 3B 7A			cmp BYTE PTR [ebx + 1*edi], "z"
 00000039  77 09			ja notLowerCase					; when char > "z", not lower case

 0000003B  80 05 00000102 R		add lowerCaseCount, 1
	   01
 00000042  EB 40			jmp continueCountLoop
 00000044			notLowerCase:
					
 00000044  80 3C 3B 41			cmp BYTE PTR [ebx + 1*edi], "A"
 00000048  72 0F			jb notUpperCase					; when char < "A", not upper case
 0000004A  80 3C 3B 5A			cmp BYTE PTR [ebx + 1*edi], "Z"
 0000004E  77 09			ja notUpperCase					; when char > "Z", not upper case

 00000050  80 05 00000103 R		add upperCaseCount, 1
	   01
 00000057  EB 2B			jmp continueCountLoop
 00000059			notUpperCase:

 00000059  80 3C 3B 30			cmp BYTE PTR [ebx + 1*edi], "0"
 0000005D  72 0F			jb notADigit					; when char < "0", not a digit
 0000005F  80 3C 3B 39			cmp BYTE PTR [ebx + 1*edi], "9"
 00000063  77 09			ja notADigit					; when char > "9", not a digit

 00000065  80 05 00000104 R		add digitCount, 1
	   01
 0000006C  EB 16			jmp continueCountLoop
 0000006E			notADigit:
					
 0000006E  80 3C 3B 20			cmp BYTE PTR [ebx + 1*edi], " "
 00000072  75 09			jne notASpace					; when char != " ", not a space

 00000074  80 05 00000105 R		add spaceCount, 1
	   01
 0000007B  EB 07			jmp continueCountLoop
 0000007D			notASpace:

					; If we get here, it is because the current character is not in any of the categories so far
					
 0000007D  80 05 00000106 R		add otherCount, 1
	   01

 00000084			continueCountLoop:
 00000084  83 C7 01			add edi, 1						; char := next character
 00000087  EB A0			jmp countLoop
 00000089			exitCountLoop:

					; Convert values to text for output
					
					; edi started at 0 and incremented for each character.
					; It now holds the number of characters in the string.
					dtoa charCountText, edi
 000000A1  B8 00000000			mov eax, 0						; blank out eax
 000000A6  A0 00000102 R		mov al, lowerCaseCount
					dtoa lowerCountText, eax
 000000C3  A0 00000103 R		mov al, upperCaseCount
					dtoa upperCountText, eax
 000000E0  A0 00000104 R		mov al, digitCount
					dtoa digitCountText, eax
 000000FD  A0 00000105 R		mov al, spaceCount
					dtoa spaceCountText, eax
 0000011A  A0 00000106 R		mov al, otherCount
					dtoa otherCountText, eax

					; Display results, using inputStr as the window title
					output inputStr, outputStr

 00000150			quit:
 00000150  B8 00000000			mov eax, 0						; exit with return code 0
					
 00000155  C3				ret
 00000156			_MainProc ENDP

				END   ; end of source code
Microsoft (R) Macro Assembler Version 11.00.50727.1	    10/13/16 20:31:14
main.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

atod . . . . . . . . . . . . . .	Proc
atow . . . . . . . . . . . . . .	Proc
dtoa . . . . . . . . . . . . . .	Proc
input  . . . . . . . . . . . . .	Proc
output . . . . . . . . . . . . .	Proc
wtoa . . . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000107 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000156 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

_MainProc  . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000156 Public
  countLoop  . . . . . . . . . .	L Near	 00000029 _TEXT	
  notLowerCase . . . . . . . . .	L Near	 00000044 _TEXT	
  notUpperCase . . . . . . . . .	L Near	 00000059 _TEXT	
  notADigit  . . . . . . . . . .	L Near	 0000006E _TEXT	
  notASpace  . . . . . . . . . .	L Near	 0000007D _TEXT	
  continueCountLoop  . . . . . .	L Near	 00000084 _TEXT	
  exitCountLoop  . . . . . . . .	L Near	 00000089 _TEXT	
  quit . . . . . . . . . . . . .	L Near	 00000150 _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
_getInput  . . . . . . . . . . .	L Near	 00000000 FLAT	External
_showOutput  . . . . . . . . . .	L Near	 00000000 FLAT	External
atodproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External
atowproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External
charCountText  . . . . . . . . .	Byte	 00000058 _DATA	
digitCountText . . . . . . . . .	Byte	 000000C8 _DATA	
digitCount . . . . . . . . . . .	Byte	 00000104 _DATA	
dtoaproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External
inputPrompt  . . . . . . . . . .	Byte	 00000029 _DATA	
inputStr . . . . . . . . . . . .	Byte	 00000000 _DATA	
lowerCaseCount . . . . . . . . .	Byte	 00000102 _DATA	
lowerCountText . . . . . . . . .	Byte	 000000A9 _DATA	
otherCountText . . . . . . . . .	Byte	 000000F0 _DATA	
otherCount . . . . . . . . . . .	Byte	 00000106 _DATA	
outputStr  . . . . . . . . . . .	Byte	 00000054 _DATA	
spaceCountText . . . . . . . . .	Byte	 000000DC _DATA	
spaceCount . . . . . . . . . . .	Byte	 00000105 _DATA	
upperCaseCount . . . . . . . . .	Byte	 00000103 _DATA	
upperCountText . . . . . . . . .	Byte	 0000008A _DATA	
wtoaproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External

	   0 Warnings
	   0 Errors
